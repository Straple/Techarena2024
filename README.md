# Techarena2024

Условие задачи:
[statements-240400.pdf](https://github.com/Straple/Techarena2024/files/15334768/statements-240400.pdf)

# Собирать
Собирать main.cpp, который читает тесты из файлов и запускает их на нашем решении с помощью CMakeLists.txt

Чтобы собрать решение для отправки в систему нужно
1) скомпилировать builder Егора с помощью /Builder/CMakeLists.txt
2) открыть консоль в корне проекта (это важно). Запустить ./Builder/Builder
3) В итоге мы получим submission.cpp

Что делает builder Егора? Читает solution.cpp. Находит #include "file". Рекурсивно читает file и вставляет его в исходный. Если мы пытаемся записать файл, который уже писали, то не делаем этого. В итоге мы типа как компилятор раскроем все #include "file" и получим submission.cpp, который можно отправить в тест систему
Это гораздо удобнее чем работать в одном файле, который у нас был в 3к строк кода, из-за чего очень сильно лагал CLion. А чтобы отправить в систему нужно просто написать одну строчку

# Визуализация

Артем сделал супер визуализацию всего решения. Не только скрины, но еще и видео того, что происходит. И мы легко в коде можем добавить строчку кода, чтобы сделать снапшот текущего сосстояния с какой-то дополнительной информацией: метрики, что за действие было выполнено и т.д.

https://github.com/Straple/Techarena2024/assets/54230867/b2578823-5399-4a33-92e4-284580f36adf

# Решение

Артем весь тур писал жадное решение, которое с нуля все строит и получает хороший балл. А также написал optimize, который улучшает итоговый ответ. А также он делал вычисление theory_max_score, что было очень полезно, ведь мы на многих тестах понимали, что уже достигли максимума, тогда давайте выйдем, делать тут уже нечего. И это действительно улучшало время работы программы, так как мы не тратили кучу действий впустую и круто анализировали ситуацию

Егор весь тур писал отжиг, потом как выяснилось с помощью визуализации отжиг тут очень плохо работает. А именно нужно было делать супер сложные операции и делать шаг, только если скор улучшается или остается таким же. То есть в итоге это град спуск

Что за действия делал Егор:
1) interval_flow_over: выбирает рандомный интервал from и пока скор улучшается, то отбирает у from длину 1 и отдает ее самому лучшему интервалу to. То есть длина интервала переливается: flow over. У этой операции было 4 разных версий
2) interval_do_split: если колво интервалов == J, то она удаляет какой-то, иначе так и оставляет. То есть делает так, чтобы интервалов было < J. Теперь выбирает интервал и делает split его на два интервала. Причем делает это очень жадно, перебирает длину, вычисляет метрики. После сплита она освобождает каких-то юзеров, у которых выполнено rbNeed. На освободившееся места пытается поставить юзеров, которые нигде не стоят
3) user_remove_and_add: берет двух случайных юзеров, удаляет их и ставить жадно в другом порядке. Так например он может поставить юзера, который не стоял или перекинуть юзера в другой блок или свапнуть этих двух юзеров местами или сделать add_left, add_right, remove_left, remove_right у юзера.

Также всегда в решении Егор поддерживается следующее: все юзеры одного цвета всегда стоят наиболее оптимально, то есть юзеров одного цвета можно свапнуть за O(1). Тогда скор может поменятся: длина осталась такой же, поменялись rbNeed. Тогда наиболее оптимально поставить юзеров это: самому большому rbNeed дать самую большую сумму длин интервалов юзера. То есть поддерживаем их в таком отсортированном порядке
